<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kuyman&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Kuyman2v.github.io/"/>
  <updated>2017-06-08T03:26:32.636Z</updated>
  <id>http://Kuyman2v.github.io/</id>
  
  <author>
    <name>Kuyman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenCV read X265/HEVC and X264 video on Ubuntu</title>
    <link href="http://Kuyman2v.github.io/2017/03/13/OpenCV-read-X265-HEVC-and-X264-video-on-Ubuntu/"/>
    <id>http://Kuyman2v.github.io/2017/03/13/OpenCV-read-X265-HEVC-and-X264-video-on-Ubuntu/</id>
    <published>2017-03-13T03:06:45.000Z</published>
    <updated>2017-06-08T03:26:32.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV-read-X265-HEVC-and-X264-video-on-Ubuntu"><a href="#OpenCV-read-X265-HEVC-and-X264-video-on-Ubuntu" class="headerlink" title="OpenCV read X265/HEVC  and X264 video on Ubuntu"></a>OpenCV read X265/HEVC and X264 video on Ubuntu</h1><h2 id="Install-X265"><a href="#Install-X265" class="headerlink" title="Install X265"></a>Install X265</h2><p>Follow the website <a href="https://bitbucket.org/multicoreware/x265" target="_blank" rel="external">X265</a>.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mercurial cmake cmake-curses-gui build-essential yasm</div><div class="line">hg <span class="built_in">clone</span> https://bitbucket.org/multicoreware/x265</div><div class="line"><span class="built_in">cd</span> x265/build/linux</div><div class="line">./make-Makefiles.bash</div><div class="line">make</div></pre></td></tr></table></figure><p></p><h2 id="Compile-FFmpeg-with-X265-amp-X264"><a href="#Compile-FFmpeg-with-X265-amp-X264" class="headerlink" title="Compile FFmpeg with X265 &amp; X264"></a>Compile FFmpeg with X265 &amp; X264</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/FFmpeg/FFmpeg.git</div><div class="line">./configure --<span class="built_in">enable</span>-gpl --<span class="built_in">enable</span>-shared --<span class="built_in">enable</span>-nonfree --<span class="built_in">enable</span>-pic --<span class="built_in">enable</span>-libx265 --<span class="built_in">enable</span>-libx264</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure><h2 id="Compile-OpenCV"><a href="#Compile-OpenCV" class="headerlink" title="Compile OpenCV"></a>Compile OpenCV</h2><p><code>Here, you can compile OpenCV with your own configuration.</code><br><code>After compiling OpenCV, it will add ffmpeg including x264&amp;x265 into OpenCV&#39;s environment.</code></p><p>Example<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/opencv/opencv.git</div><div class="line">cd opencv &amp;&amp; mkdir build &amp;&amp; cd build</div><div class="line">cmake -D WITH_TBB=ON -D BUILD_NEW_PYTHON_SUPPORT=ON -D WITH_V4L=ON  -D WITH_QT=ON -D WITH_OPENGL=ON -D WITH_VTK=ON -D WITH_CUDA=ON -DCMAKE_INSTALL_PREFIX=/usr  ..</div><div class="line">make </div><div class="line">sudo make install</div></pre></td></tr></table></figure><p></p><h2 id="Test-Code"><a href="#Test-Code" class="headerlink" title="Test Code"></a>Test Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">  <span class="function">VideoCapture <span class="title">cap</span><span class="params">(argv[<span class="number">1</span>])</span></span>;</div><div class="line">  cap.<span class="built_in">set</span>(CV_CAP_PROP_FOURCC, CV_FOURCC(<span class="string">'H'</span>, <span class="string">'E'</span>, <span class="string">'V'</span>, <span class="string">'C'</span>));</div><div class="line">  <span class="keyword">if</span> (!cap.isOpened()) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">    Mat frame;</div><div class="line">    cap &gt;&gt; frame;</div><div class="line">    imshow(<span class="string">"display"</span>, frame);</div><div class="line">    <span class="keyword">if</span> (waitKey(<span class="number">20</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Download h265 file <a href="http://jell.yfish.us/" target="_blank" rel="external">here</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OpenCV-read-X265-HEVC-and-X264-video-on-Ubuntu&quot;&gt;&lt;a href=&quot;#OpenCV-read-X265-HEVC-and-X264-video-on-Ubuntu&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
    
      <category term="X265" scheme="http://Kuyman2v.github.io/tags/X265/"/>
    
  </entry>
  
  <entry>
    <title>Linux的账号管理</title>
    <link href="http://Kuyman2v.github.io/2016/12/23/Linux-admin/"/>
    <id>http://Kuyman2v.github.io/2016/12/23/Linux-admin/</id>
    <published>2016-12-23T13:32:43.000Z</published>
    <updated>2017-06-08T03:26:32.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux的账号与群组"><a href="#Linux的账号与群组" class="headerlink" title="Linux的账号与群组"></a>Linux的账号与群组</h2><h3 id="使用者标识码：UID与GID"><a href="#使用者标识码：UID与GID" class="headerlink" title="使用者标识码：UID与GID"></a>使用者标识码：UID与GID</h3><p><code>UID</code>对应用户ID,<code>GID</code>对群组ID<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id [user]</div></pre></td></tr></table></figure><p></p><h3 id="使用者账号"><a href="#使用者账号" class="headerlink" title="使用者账号"></a>使用者账号</h3><h4 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h4><p>一共有７个字段</p><ul><li>1、账号名称：需要用来对应UID，例如root的UID对应是0</li><li>2、密码：早期Unix系统的密码就是放在这个字段上！但是因为这个文件的特性是所有的程序都能够读取，这样一来很容易造成数据被窃取，因此后来就将这个字段的密码数据改到/etc/shadow中了。所以这里有一个”x”</li><li>3、UID：这个就是使用者的标识码，通常Linux对于UID有几个限制：</li></ul><table><thead><tr><th>id 范围</th><th>该 ID 使用者特性</th></tr></thead><tbody><tr><td>0（系统管理员）</td><td>当 UID 是 0 时，代表这个帐号是“系统管理员”！ 所以当你要让其他的帐号名称也具有 root 的权限时，将该帐号的 UID 改为 0 即可。 这也就是说，一部系统上面的系统管理员不见得只有 root 喔！ 不过，很不建议有多个帐号的 UID 是 0 啦～容易让系统管理员混乱！</td></tr><tr><td>1~999（系统帐号）</td><td>保留给系统使用的 ID，其实除了 0 之外，其他的 UID 权限与特性并没有不一样。默认 1000 以下的数字让给系统作为保留帐号只是一个习惯。由于系统上面启动的网络服务或背景服务希望使用较小的权限去运行，因此不希望使用 root 的身份去执行这些服务， 所以我们就得要提供这些运行中程序的拥有者帐号才行。这些系统帐号通常是不可登陆的,/sbin/nologin 这个特殊的 shell 存在。根据系统帐号的由来，通常这类帐号又约略被区分为两种：1~200：由 distributions 自行创建的系统帐号；201~999：若使用者有系统帐号需求时，可以使用的帐号 UID。</td></tr><tr><td>1000~60000（可登陆帐号）</td><td>给一般使用者用的。事实上，目前的 linux 核心 （3.10.x 版）已经可以支持到 4294967295 （2^32-1） 这么大的 UID 号码喔！</td></tr></tbody></table><ul><li>4、GID：这个与/etc/group有关，其实/etc/group的观念与/etc/passwd差不多，只是它是用来规范群组名称与GID的对应而已。</li><li>5、使用者说明栏：基本没有什么重要用途，只是用来解释这个账号的意义而已，不过提供finger的功能是，这个字段可以提供很多的讯息。</li><li>6、主文件夹：这是使用者的文件夹，以上面为例，root的主文件夹在/root，所以当root登录之后，就会立即跑到/root目录里来</li><li>7、Shell：默认是bash</li><li>8、/etc/shadow文件结构</li></ul><h4 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h4><p>一共有九个字段</p><ul><li>1、账号名称</li><li>2、加密密码</li><li>3、最近改动密码的日期</li><li>4、密码不可被更改的天数</li><li>5、密码需要重新变更的天数</li><li>6、密码需要变更期限前的警告天数</li><li>7、密码过期够的账号宽限天数</li><li>8、账号失效日期</li><li>9、保留</li></ul><p>日期是以1970年的总日数设置的，例如16559是2015/05/04</p><h3 id="有关群组：有效与初始群组、groups-newgrp"><a href="#有关群组：有效与初始群组、groups-newgrp" class="headerlink" title="有关群组：有效与初始群组、groups, newgrp"></a>有关群组：有效与初始群组、groups, newgrp</h3><h4 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h4><p>这个文件就是记录GID与群组名称的对应,类似与这样：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@study ~]# head -n 4 /etc/group</div><div class="line">root:x:0:</div><div class="line">bin:x:1:</div><div class="line">daemon:x:2:</div><div class="line">sys:x:3:</div></pre></td></tr></table></figure><p></p><p>分为四栏</p><ul><li>1、群组名称</li><li>2、群组密码：通常不设置，这个通常给群组管理员使用，目前很少设置群组管理员，同意移到/etc/gshadow去，因此这个字段只会存在一个”x”</li><li>3、GID：群组ID，与群组名对应</li><li>4、此群组支持的账号名称：一个账号可以加入多个群组，那某个账号想要加入此群组时，将该账号填入这个字段即可。</li></ul><p><img src="https://ooo.0o0.ooo/2016/12/23/585ccd1ea9ce2.png" alt="Screenshot from 2016-12-23 15-06-37.png"></p><p><code>Tips</code> 在新版的Linux中，初始群组的用户群已经不会加入在第四个字段。例如我们知道root这个账号的主要群组为root，但是在上面的范例中，你已经不会看到root这个用户的名称在/etc/group的root那一行的第四个字段内。</p><h4 id="有效群组与初始群组"><a href="#有效群组与初始群组" class="headerlink" title="有效群组与初始群组"></a>有效群组与初始群组</h4><h5 id="初始群组"><a href="#初始群组" class="headerlink" title="初始群组"></a>初始群组</h5><p>每个使用者在他的/etc/passwd里面的第四栏有所谓的GID，这个GID就是所谓的”初始群组”，也就是说，当使用者一登录系统，立即就拥有这个群组的相关权限。</p><h5 id="有效群组"><a href="#有效群组" class="headerlink" title="有效群组"></a>有效群组</h5><p>当用户创建一个新的文件或者新的目录是，新文件的群组是？这个时候就需要检查当时的有效群组了。</p><ul><li>groups<br>groups命令会输出当前用户所属的所有群组，其中第一个就是有效群组</li><li>newgrp<br>有效群组的切换，同时会更改shell</li></ul><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h3 id="新增与移除使用者：useradd-相关配置文件-passwd，usermod-userdel"><a href="#新增与移除使用者：useradd-相关配置文件-passwd，usermod-userdel" class="headerlink" title="新增与移除使用者：useradd,相关配置文件,passwd，usermod,userdel"></a>新增与移除使用者：useradd,相关配置文件,passwd，usermod,userdel</h3><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p>useradd创建账号是，至少会参考：</p><ul><li>/etc/default/useradd</li><li>/etc/login.defs</li><li>/etc/skel/*</li></ul><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>用root给user赋予密码<code>passwd username</code></p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>usermode用来修改/etc/passwd或者/etc/shadow字段数据<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod [-cdegGlsuLU] username</div></pre></td></tr></table></figure><p></p><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">userdel -r username</div></pre></td></tr></table></figure><p>连同使用者的主文件一起删除</p><h3 id="使用者功能"><a href="#使用者功能" class="headerlink" title="使用者功能"></a>使用者功能</h3><p>useradd/usermod/userdel都是系统管理员所能够使用的指令<br>一般用户常用指令如下：</p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>查询某人或自己的相关UID/GID等等信息<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id [username]</div></pre></td></tr></table></figure><p></p><h4 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h4><p><code>finger username</code>观察使用者相关账号属性<br><code>finger</code>指令找出系统上登陆的使用者与登陆时间</p><h4 id="chfn"><a href="#chfn" class="headerlink" title="chfn"></a>chfn</h4><p>chfn有点像change finger的意思，使用如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chfn [-foph] [username]</div></pre></td></tr></table></figure><p></p><h4 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h4><p>修改自己的shell参数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chsh [-ls]</div></pre></td></tr></table></figure><p></p><h3 id="新增与移除群组"><a href="#新增与移除群组" class="headerlink" title="新增与移除群组"></a>新增与移除群组</h3><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groupadd [-g gid] [-r] 群组名称</div></pre></td></tr></table></figure><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><p>跟usermod类似，这个指令进行group相关参数的修改<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groupmod [-g gid] [-n group_name] 群组名</div></pre></td></tr></table></figure><p></p><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groupdel [groupname]</div></pre></td></tr></table></figure><p>如果某个用户的出初始化用户组使用的该群组，则不能通过这个命令删除</p><h4 id="gpasswd"><a href="#gpasswd" class="headerlink" title="gpasswd"></a>gpasswd</h4><p>群组管理员功能<br>账号名称|账号全名|支持次要群组|是否可登陆主机|密码<br>—|—|—|—|—<br>myuser1|1st user|mygroup1|可以|password<br>myuser2|2nd user|mygroup1|可以|password<br>myuser3|3rd user|无额外支持|不可以|password</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">groupadd mygroup1</div><div class="line">useradd -G mygroup1 -c &quot;1st user&quot; myuser1</div><div class="line">useradd -G mygroup2 -c &quot;2nd user&quot; myuser2</div><div class="line">useradd -c &quot;3rd user&quot; -s /sbin/nologin myuser3</div><div class="line"></div><div class="line">passwd myuser1</div><div class="line">passwd myuser2</div><div class="line">passwd myuser3</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux的账号与群组&quot;&gt;&lt;a href=&quot;#Linux的账号与群组&quot; class=&quot;headerlink&quot; title=&quot;Linux的账号与群组&quot;&gt;&lt;/a&gt;Linux的账号与群组&lt;/h2&gt;&lt;h3 id=&quot;使用者标识码：UID与GID&quot;&gt;&lt;a href=&quot;#使用者
    
    </summary>
    
    
      <category term="Linux" scheme="http://Kuyman2v.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的/etc/passwd和/etc/shadow</title>
    <link href="http://Kuyman2v.github.io/2016/12/23/Linux%EF%BC%8C-etc-passwd%EF%BC%8C-etc-shadow/"/>
    <id>http://Kuyman2v.github.io/2016/12/23/Linux，-etc-passwd，-etc-shadow/</id>
    <published>2016-12-23T06:48:01.000Z</published>
    <updated>2017-06-08T03:26:32.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h2><p>一共有７个字段</p><ul><li>1、账号名称：需要用来对应UID，例如root的UID对应是0</li><li>2、密码：早期Unix系统的密码就是放在这个字段上！但是因为这个文件的特性是所有的程序都能够读取，这样一来很容易造成数据被窃取，因此后来就将这个字段的密码数据改到/etc/shadow中了。所以这里有一个”x”</li><li>3、UID：这个就是使用者的标识码，通常Linux对于UID有几个限制：</li></ul><table><thead><tr><th>id 范围</th><th>该 ID 使用者特性</th></tr></thead><tbody><tr><td>0（系统管理员）</td><td>当 UID 是 0 时，代表这个帐号是“系统管理员”！ 所以当你要让其他的帐号名称也具有 root 的权限时，将该帐号的 UID 改为 0 即可。 这也就是说，一部系统上面的系统管理员不见得只有 root 喔！ 不过，很不建议有多个帐号的 UID 是 0 啦～容易让系统管理员混乱！</td></tr><tr><td>1~999（系统帐号）</td><td>保留给系统使用的 ID，其实除了 0 之外，其他的 UID 权限与特性并没有不一样。默认 1000 以下的数字让给系统作为保留帐号只是一个习惯。由于系统上面启动的网络服务或背景服务希望使用较小的权限去运行，因此不希望使用 root 的身份去执行这些服务， 所以我们就得要提供这些运行中程序的拥有者帐号才行。这些系统帐号通常是不可登陆的,/sbin/nologin 这个特殊的 shell 存在。根据系统帐号的由来，通常这类帐号又约略被区分为两种：1~200：由 distributions 自行创建的系统帐号；201~999：若使用者有系统帐号需求时，可以使用的帐号 UID。</td></tr><tr><td>1000~60000（可登陆帐号）</td><td>给一般使用者用的。事实上，目前的 linux 核心 （3.10.x 版）已经可以支持到 4294967295 （2^32-1） 这么大的 UID 号码喔！</td></tr></tbody></table><ul><li>4、GID：这个与/etc/group有关，其实/etc/group的观念与/etc/passwd差不多，只是它是用来规范群组名称与GID的对应而已。</li><li>5、使用者说明栏：基本没有什么重要用途，只是用来解释这个账号的意义而已，不过提供finger的功能是，这个字段可以提供很多的讯息。</li><li>6、主文件夹：这是使用者的文件夹，以上面为例，root的主文件夹在/root，所以当root登录之后，就会立即跑到/root目录里来</li><li>7、Shell：默认是bash</li><li>8、/etc/shadow文件结构</li></ul><h2 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h2><p>一共有九个字段</p><ul><li>1、账号名称</li><li>2、加密密码</li><li>3、最近改动密码的日期</li><li>4、密码不可被更改的天数</li><li>5、密码需要重新变更的天数</li><li>6、密码需要变更期限前的警告天数</li><li>7、密码过期够的账号宽限天数</li><li>8、账号失效日期</li><li>9、保留</li></ul><p>日期是以1970年的总日数设置的，例如16559是2015/05/04</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;etc-passwd&quot;&gt;&lt;a href=&quot;#etc-passwd&quot; class=&quot;headerlink&quot; title=&quot;/etc/passwd&quot;&gt;&lt;/a&gt;/etc/passwd&lt;/h2&gt;&lt;p&gt;一共有７个字段&lt;/p&gt;&lt;ul&gt;&lt;li&gt;1、账号名称：需要用来对应UID，
    
    </summary>
    
    
      <category term="Linux" scheme="http://Kuyman2v.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ROS Lesson3</title>
    <link href="http://Kuyman2v.github.io/2016/12/20/ROS-Lesson3/"/>
    <id>http://Kuyman2v.github.io/2016/12/20/ROS-Lesson3/</id>
    <published>2016-12-20T14:28:34.000Z</published>
    <updated>2017-06-08T03:26:32.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Agenda"><a href="#Agenda" class="headerlink" title="Agenda"></a>Agenda</h2><blockquote><ul><li>向topics发送messages</li><li>订阅topics</li><li>差动驱动机器人</li><li>在代码中发送速度</li><li>roslaunch</li></ul></blockquote><h2 id="ros-Publisher"><a href="#ros-Publisher" class="headerlink" title="ros::Publisher"></a>ros::Publisher</h2><blockquote><ul><li>在一个特殊的topic上管理通告</li><li>通过调用NodeHandle::advertise()被创建<ul><li>在master节点中注册这个topic</li></ul></li><li>一个创建publisher的例子</li></ul></blockquote><pre><code>ros::Publisher chatter_pub = node.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000);

+ 第一个参数是topic名字
+ 第二个参数是发送队列大小
</code></pre><blockquote><ul><li>对于一个给定的topic，一旦所有的publisher超出范围，这个topic将不会被公告</li><li>在一个topic上发布消息调用publish()</li><li>例如：</li></ul></blockquote><p>std_msgs::String msg;<br>chatter_pub.publish(msg);</p><blockquote><ul><li>这个消息的类型必须与advertise&lt;&gt;()调用的模板参数一致</li></ul></blockquote><h2 id="Talker-and-Listener"><a href="#Talker-and-Listener" class="headerlink" title="Talker and Listener"></a>Talker and Listener</h2><blockquote><ul><li>我们现在创建了一个有两个节点的package：<ul><li>talker向topic “chatter”发布消息</li><li>listener从这个topic中读取消息，并将其打印出来</li></ul></li><li>首先创建一个package chat_pkg</li></ul></blockquote><pre><code>cd ~/catkin_ws/src
catkin_create_pkg chat_pkg std_msgs rospy roscpp
</code></pre><blockquote><ul><li>在Eclipse中打开package的源代码文件夹，然后添加一个C++的源文件Talker.cpp</li><li>复制下面的代码进去<h3 id="Tralker-cpp"><a href="#Tralker-cpp" class="headerlink" title="Tralker.cpp"></a>Tralker.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"std_msgs/String.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line"> ros::init(argc, argv, <span class="string">"talker"</span>); <span class="comment">// Initiate new ROS node named "talker"</span></div><div class="line"> ros::NodeHandle node;</div><div class="line"> ros::Publisher chatter_pub = node.advertise&lt;std_msgs::String&gt;(<span class="string">"chatter"</span>, <span class="number">1000</span>);</div><div class="line"> ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line"> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"> <span class="keyword">while</span> (ros::ok()) <span class="comment">// Keep spinning loop until user presses Ctrl+C</span></div><div class="line"> &#123;</div><div class="line"> std_msgs::String msg;</div><div class="line"> <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</div><div class="line"> ss &lt;&lt; <span class="string">"hello world "</span> &lt;&lt; count;</div><div class="line"> msg.data = ss.str();</div><div class="line"> ROS_INFO(<span class="string">"%s"</span>, msg.data.c_str());</div><div class="line"> chatter_pub.publish(msg);</div><div class="line"> ros::spinOnce(); <span class="comment">// Need to call this function often to allow ROS to process incoming messages</span></div><div class="line"> loop_rate.sleep(); <span class="comment">// Sleep for the rest of the cycle, to enforce the loop rate</span></div><div class="line"> count++;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></blockquote><h2 id="Subcribing-to-a-Topic"><a href="#Subcribing-to-a-Topic" class="headerlink" title="Subcribing to a Topic"></a>Subcribing to a Topic</h2><blockquote><ul><li>开始收听一个topic，调用节点句柄的subcribe()<ul><li>这会返回一个Subcriber对象，你必须该对象直到hold it直到你想退订为止</li></ul></li><li>创建subscriber的例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ros::Subscriber sub = node.subscribe(&quot;chatter&quot;, 1000, messageCallback);</div></pre></td></tr></table></figure></li></ul></blockquote><ul><li>第一个参数是topic的名字</li><li>第二个参数是队列大小</li><li>第三个是处理消息的函数<h3 id="Listener-cpp"><a href="#Listener-cpp" class="headerlink" title="Listener.cpp"></a>Listener.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"std_msgs/String.h"</span></span></div><div class="line"><span class="comment">// Topic messages callback</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">chatterCallback</span><span class="params">(<span class="keyword">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span></div><div class="line">&#123;</div><div class="line"> ROS_INFO(<span class="string">"I heard: [%s]"</span>, msg-&gt;data.c_str());</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line"> <span class="comment">// Initiate a new ROS node named "listener"</span></div><div class="line"> ros::init(argc, argv, <span class="string">"listener"</span>);</div><div class="line"> ros::NodeHandle node;</div><div class="line"> <span class="comment">// Subscribe to a given topic</span></div><div class="line"> ros::Subscriber sub = node.subscribe(<span class="string">"chatter"</span>, <span class="number">1000</span>, chatterCallback);</div><div class="line"> <span class="comment">// Enter a loop, pumping callbacks</span></div><div class="line"> ros::spin();</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure></li></ul><h3 id="ros-spin-vs-ros-spinOnce"><a href="#ros-spin-vs-ros-spinOnce" class="headerlink" title="ros::spin() vs ros::spinOnce()"></a>ros::spin() vs ros::spinOnce()</h3><ul><li><p>ros::spin()将控制交给ROS，允许它调用所有的用户回调函数</p><ul><li>只有当节点被关闭，或者调用了ros::shutdown()或者Ctrl-C<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/calback_queue.h&gt;</span></span></div><div class="line">ros::NodeHandle n;</div><div class="line"><span class="keyword">while</span>(ros::ok()</div><div class="line">&#123;</div><div class="line">    ros::getGlobalCallbackQueue()-&gt;callAvailable(ros::WallDuration(<span class="number">0.1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>ros::spinOnce()将会调用当前正在等候队列的回调函数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/callback_queue.h&gt;</span></span></div><div class="line">ros::getGlobalCallBackQueue()-&gt;callAvailable(ros::WallDuration(<span class="number">0</span>));</div></pre></td></tr></table></figure><ul><li>一个一般的模式是周期性的调用spinOnce()<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ros::<span class="function">Rate <span class="title">r</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line"><span class="keyword">while</span>(should_continue) </div><div class="line">&#123;</div><div class="line">    ... <span class="keyword">do</span> some work, publish some messages, etc. ...</div><div class="line">ros::spinOnce();</div><div class="line">r.sleep();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="Using-Class-Method-as-Callbacks"><a href="#Using-Class-Method-as-Callbacks" class="headerlink" title="Using Class Method as Callbacks"></a>Using Class Method as Callbacks</h3><ul><li><p>假如你有一个简单的class，Listener</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后NodeHandle::subscribe()像下面这样调用类的方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Listener listener;</div><div class="line">ros::Subscriber sub = node.subscribe(<span class="string">"chatter"</span>, <span class="number">1000</span>, &amp;Listener::calback, &amp;listener);</div></pre></td></tr></table></figure></li></ul><h3 id="Compile-the-Nodes"><a href="#Compile-the-Nodes" class="headerlink" title="Compile the Nodes"></a>Compile the Nodes</h3><ul><li>在这个package的CMakeLists文件中添加如下语句<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</div><div class="line"><span class="keyword">project</span>(chat_pkg)</div><div class="line">...</div><div class="line"><span class="comment">## Declare a cpp executable</span></div><div class="line"><span class="keyword">add_executable</span>(talker src/Talker.cpp)</div><div class="line"><span class="keyword">add_executable</span>(listener src/Listener.cpp)</div><div class="line"><span class="comment">## Specify libraries to link a library or executable target against</span></div><div class="line"><span class="keyword">target_link_libraries</span>(talker <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</div><div class="line"><span class="keyword">target_link_libraries</span>(listener <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</div></pre></td></tr></table></figure></li></ul><h3 id="Runing-the-Nodes-From-Terminal"><a href="#Runing-the-Nodes-From-Terminal" class="headerlink" title="Runing the Nodes From Terminal"></a>Runing the Nodes From Terminal</h3><ul><li>运行roscore</li><li>在两个不同的终端运行节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rosrun chat_pkg talker</div><div class="line">rosrun chat_pkg listener</div></pre></td></tr></table></figure></li></ul><h3 id="Ros-Names"><a href="#Ros-Names" class="headerlink" title="Ros Names"></a>Ros Names</h3><ul><li>ROS的名字必须是独一无二的</li><li>如果相同的节点被lauch两次，roscore指示以前的节点退出</li><li>要在命令行中改变节点名，能使用_name语法</li><li>下面两个shell命令将会lauch两个实例，talker1,talker2<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rosrun chat_pkg talker __name:=talker1</div><div class="line">rosrun chat_pkg talker __name:=talker2</div></pre></td></tr></table></figure></li></ul><h2 id="roslaunch"><a href="#roslaunch" class="headerlink" title="roslaunch"></a>roslaunch</h2><h3 id="roslaunch-1"><a href="#roslaunch-1" class="headerlink" title="roslaunch"></a>roslaunch</h3><ul><li>一个简单的工具，用来launch 多个ROS 节点，并设置参数服务器中的参数。</li><li>roslaunch 操作与launch文件，这个文件是一个XML文件，以.launch为后缀</li><li>语法<code>roslaunch PACKAGE LAUNCH_FILE</code></li><li>roslaunch能自动的为你运行节点</li></ul><h3 id="Launch-File-Example"><a href="#Launch-File-Example" class="headerlink" title="Launch File Example"></a>Launch File Example</h3><ul><li><p>一个launch talker 和listener节点的launch file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;launch&gt; </div><div class="line">  &lt;node name=&quot;talker&quot; pkg=&quot;chat_pkg&quot; type=&quot;talker&quot; output=&quot;screen&quot;/&gt; </div><div class="line">  &lt;node name=&quot;listener&quot; pkg=&quot;chat_pkg&quot; type=&quot;listener&quot; output=&quot;screen&quot;/&gt; </div><div class="line">&lt;/launch&gt;</div></pre></td></tr></table></figure></li><li><p>每一个<node>标签包含一些属性，用来申明节点的ROS graph name，他们能在这个package中找到，这个node 的名字是这个可执行程序的文件名。</node></p></li><li>output=”screen”让ROS在终端窗口打印调试信息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">roslaunch chat_pkg chat.launch</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Agenda&quot;&gt;&lt;a href=&quot;#Agenda&quot; class=&quot;headerlink&quot; title=&quot;Agenda&quot;&gt;&lt;/a&gt;Agenda&lt;/h2&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;向topics发送messages&lt;/li&gt;&lt;li&gt;订阅topics&lt;/l
    
    </summary>
    
    
      <category term="ROS Lesson" scheme="http://Kuyman2v.github.io/tags/ROS-Lesson/"/>
    
  </entry>
  
  <entry>
    <title>ROS Lesson2</title>
    <link href="http://Kuyman2v.github.io/2016/12/07/ROS-Lesson2/"/>
    <id>http://Kuyman2v.github.io/2016/12/07/ROS-Lesson2/</id>
    <published>2016-12-07T14:42:04.000Z</published>
    <updated>2017-06-08T03:26:32.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Agenda"><a href="#Agenda" class="headerlink" title="Agenda"></a>Agenda</h2><blockquote><ul><li>ROS的基本命令</li><li>ROS开发环境的建立</li><li>ROS package结构</li><li>ROS与eclipse的集成</li><li>写你的第一个node</li><li>运行和调试你的node</li></ul></blockquote><h2 id="ROS的基本命令"><a href="#ROS的基本命令" class="headerlink" title="ROS的基本命令"></a>ROS的基本命令</h2><blockquote><ul><li>roscore</li><li>rosrun</li><li>rosnode</li><li>rostopic<h3 id="roscore"><a href="#roscore" class="headerlink" title="roscore"></a>roscore</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">roscore</div></pre></td></tr></table></figure></li></ul></blockquote><p>roscore将会开启</p><blockquote><ul><li>一个 ROS Master</li><li>一个 ROS参数服务器</li><li>一个rosout日志节点</li></ul></blockquote><h3 id="rosrun"><a href="#rosrun" class="headerlink" title="rosrun"></a>rosrun</h3><p>rosrun允许你运行一个节点<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosrun &lt;package&gt; &lt;executable&gt;</div></pre></td></tr></table></figure><p></p><h3 id="rosnode"><a href="#rosnode" class="headerlink" title="rosnode"></a>rosnode</h3><p>显示关于ROS nodes调试信息，包含发布、订阅和连接信息</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>$rosnode list</td><td>列出活跃节点</td></tr><tr><td>$rosnode ping</td><td>测试节点的连接情况</td></tr><tr><td>$rosnode info</td><td>打印节点信息</td></tr><tr><td>$rosnode kill</td><td>杀死一个运行节点</td></tr><tr><td>$rosnode mechine</td><td>显示某个机器上运行的节点</td></tr></tbody></table><h3 id="rostopic"><a href="#rostopic" class="headerlink" title="rostopic"></a>rostopic</h3><p>给出关于一个topic的信息，并在这个topic上发布信息</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>$rostopic list</td><td>列出活跃的topic</td></tr><tr><td>$rosnode echo /topic</td><td>打印topic的message到屏幕上</td></tr><tr><td>$rostopic info /topic</td><td>打印关于这个topic的信息</td></tr><tr><td>$rostopic type /topic</td><td>打印这个topic发布的message类型</td></tr><tr><td>$rostopic pub /topic type args</td><td>发布数据到一个topic上</td></tr></tbody></table><h3 id="catkin-Build-System"><a href="#catkin-Build-System" class="headerlink" title="catkin Build System"></a>catkin Build System</h3><blockquote><p>*catkin是BOS的build系统</p><pre><code>- 用来生成可执行文件、库文件和接口的一系列工具
</code></pre><p>*用传统的cmake宏和一些python代码实现的</p></blockquote><h3 id="catkin-Workspace"><a href="#catkin-Workspace" class="headerlink" title="catkin Workspace"></a>catkin Workspace</h3><blockquote><ul><li>ROS代码所处的一系列的目录</li><li>你能有多个ROS workspaces， 但是你一次只能在一个workspace中工作</li><li>workspace包含下列空间</li></ul></blockquote><table><thead><tr><th>Space</th><th>用途</th></tr></thead><tbody><tr><td>Source Space</td><td>包含了catkin packages的源代码。source中的每一个路径包含一个到多个catkin packages</td></tr><tr><td>Build Space</td><td>cmake build后在这里保存缓存信息和其他的中间文件</td></tr><tr><td>Development(Devel) Space</td><td>生成的目标文件在被安装之前放在这里</td></tr><tr><td>Install Space</td><td>一旦目标文件生成之后，他们能被安装在这里</td></tr></tbody></table><h3 id="catkin-Workspace-Layout"><a href="#catkin-Workspace-Layout" class="headerlink" title="catkin Workspace Layout"></a>catkin Workspace Layout</h3><center><img src="https://ooo.0o0.ooo/2016/12/07/58480e5ee2242.png" alt="Screenshot from 2016-12-07 21-27-38.png"></center><h2 id="ROS-Development-Setup"><a href="#ROS-Development-Setup" class="headerlink" title="ROS Development Setup"></a>ROS Development Setup</h2><blockquote><ul><li>创建一个catkin workspace</li><li>创建一个新的ROS package</li><li>下载和配置Eclipse</li><li>为你的package创建eclipse工程文件</li><li>导入package到eclipse</li><li>写代码</li><li>更新make文件</li><li>build这个package</li></ul></blockquote><h3 id="创建一个catkin-worksapce"><a href="#创建一个catkin-worksapce" class="headerlink" title="创建一个catkin worksapce"></a>创建一个catkin worksapce</h3><blockquote><ul><li><p><a href="http://wiki.ros.org/catkin/Tutorials/create_a_workspace" target="_blank" rel="external">创建向导</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">makir -p ~/catkin_ws/src</div><div class="line"><span class="built_in">cd</span> ~/catkin_ws/src</div><div class="line">catkin_init_workspace</div></pre></td></tr></table></figure></li><li><p>一开始，这个工作空间只包含顶层的CMakeLists.txt</p></li><li>catkin_make命令将会编译这个工作空间中的所有package<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/catkin_ws</div><div class="line">catkin_make</div></pre></td></tr></table></figure></li></ul></blockquote><h3 id="ROS-Package"><a href="#ROS-Package" class="headerlink" title="ROS Package"></a>ROS Package</h3><blockquote><ul><li>ROS的软件被组织进packages中，每一个package都包含一些代码、数据和文件</li><li>catkin workspace中的一个package只是一个简单的目录，在这个目录中有一个package.xml文件</li><li>package是编译和发行最基本的单元</li><li>一个package包含一个或者多个节点的源代码和配置文件<h4 id="一般的文件和文件夹"><a href="#一般的文件和文件夹" class="headerlink" title="一般的文件和文件夹"></a>一般的文件和文件夹</h4></li></ul></blockquote><table><thead><tr><th>文件夹</th><th>说明</th></tr></thead><tbody><tr><td>include/</td><td>C++头文件</td></tr><tr><td>src/</td><td>源文件</td></tr><tr><td>msg/</td><td>包含Message(msg)类型的文件夹</td></tr><tr><td>srv/</td><td>包含Service(srv)类型的文件夹</td></tr><tr><td>launch/</td><td>包含launch文件的文件夹</td></tr><tr><td>package.xml</td><td>这个package的表单</td></tr><tr><td>CMakLists.txt</td><td>cmake的build文件</td></tr></tbody></table><h4 id="The-Package-Manifest"><a href="#The-Package-Manifest" class="headerlink" title="The Package Manifest"></a>The Package Manifest</h4><blockquote><ul><li>package.xml定义了这个package的属性：<ul><li>package名</li><li>版本号</li><li>作者</li><li>对其他catkin package的依赖</li><li>等等</li></ul></li><li>一个例子<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;package&gt;</div><div class="line">    &lt;name&gt;foo_core&lt;/name&gt;</div><div class="line">    &lt;version&gt;1.2.4&lt;/version&gt;</div><div class="line">    &lt;description&gt;</div><div class="line">        This package provides foo capability.</div><div class="line">    &lt;/description&gt;</div><div class="line">    &lt;maintainer email="huang.volcano@gmail.com" Can HUANG &lt;/maintainer&gt;</div><div class="line">    &lt;license&gt;BSD&lt;/license&gt;</div><div class="line">    </div><div class="line">    &lt;url&gt;http://ros.orh/wike/foo_core&lt;/url&gt;</div><div class="line">    &lt;author&gt;Can HUANG&lt;/author&gt;</div><div class="line">    </div><div class="line">    &lt;build_depend&gt;message_generation&lt;/build_depend&gt;</div><div class="line">    &lt;build_depend&gt;roscpp&lt;/build_depend&gt;</div><div class="line">    &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;</div><div class="line">    </div><div class="line">    &lt;run_depend&gt;message_runrime&lt;/run_depend&gt;</div><div class="line">    &lt;run_depend&gt;roscpp&lt;/run_depend&gt;</div><div class="line">    &lt;run_depend&gt;rospy&lt;/run_depend&gt;</div><div class="line">    &lt;run_depend&gt;std_msgs&lt;/run_depend&gt;</div><div class="line">    </div><div class="line">    &lt;test_depend&gt;python-mock&lt;/test_depend&gt;</div><div class="line">&lt;/package&gt;</div></pre></td></tr></table></figure></li></ul></blockquote><h4 id="创建一个ROS-package"><a href="#创建一个ROS-package" class="headerlink" title="创建一个ROS package"></a>创建一个ROS package</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~/catkin_ws/src</div><div class="line">catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</div></pre></td></tr></table></figure><p>例如<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">catkin_create_pkg first_pkg std_msgs rospy roscpp</div></pre></td></tr></table></figure><p></p><h3 id="Eclipse与ROS的集成"><a href="#Eclipse与ROS的集成" class="headerlink" title="Eclipse与ROS的集成"></a>Eclipse与ROS的集成</h3><h4 id="Install-Eclipse"><a href="#Install-Eclipse" class="headerlink" title="Install Eclipse"></a>Install Eclipse</h4><blockquote><ul><li><p>确保安装了jvm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install default-jre</div></pre></td></tr></table></figure></li><li><p><a href="https://www.eclipse.org/downloads/eclipse-packages/" target="_blank" rel="external">下载</a>eclipse IDE for C/C++ developers</p></li><li>提取eclipse到一个文件夹</li><li><p>把eclipse移到/opt文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mv eclipse /opt</div></pre></td></tr></table></figure></li><li><p>创建一个链接以便让其他用户使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo ln -s /opt/eclipse/eclipse /usr/bin/eclipse</div><div class="line">``` </div><div class="line">&gt;* 在Unity Dash中创建快捷访问</div><div class="line"><span class="variable">$sudo</span> gedit /usr/share/applications/eclipse.desktop</div></pre></td></tr></table></figure></li></ul></blockquote><p>[Desktop Entry]<br>Name=Eclipse<br>Type=Application<br>Exec=bash -i -c “/opt/eclipse/eclipse”<br>Terminal=false<br>Icon=/opt/eclipse/icon.xpm<br>Comment=Integrated Development Environment<br>NoDisplay=false<br>Categories=Devilopment;IDE<br>Name[en]=eclipse.desktop<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### Make Eclipse Project Files</div><div class="line">```bash</div><div class="line">cd ~/catkin_ws</div><div class="line">catkin_make_ --force-cmake -G&quot;Eclipse CDT4 - Unix Makefiles&quot;</div></pre></td></tr></table></figure><p></p><p>eclipse的工程文件将会在~/catkin_ws/build中生成</p><h4 id="导入工程到Eclipse中"><a href="#导入工程到Eclipse中" class="headerlink" title="导入工程到Eclipse中"></a>导入工程到Eclipse中</h4><blockquote><ul><li>打开eclipse</li><li>选择catkin_ws文件夹作为工作空间<center><img src="https://ooo.0o0.ooo/2016/12/08/5848aa1e48e22.png" alt="1.png"></center></li><li>依次选择File –&gt; Import –&gt; General –&gt; Existing Project into Workspace<center><img src="https://ooo.0o0.ooo/2016/12/08/5848aa1e6682b.png" alt="2.png"></center></li><li>现在从~/catkin_ws/build文件夹中导入工程<center><img src="https://ooo.0o0.ooo/2016/12/08/5848aa1e6592f.png" alt="3.png"></center></li><li>默认地，elipse的智能感知将不会识别这个系统的头文件(像<string>).解决如下：<ul><li>点Project Propertios –&gt; C/C++ General –&gt; Preprocessor Include Paths, Macros, etc. –&gt; Providers tab</li><li>Check CDT GCC Build-in Compiler Settings [Shared]<center><img src="https://ooo.0o0.ooo/2016/12/08/5848aa1e6770d.png" alt="5.png"></center></li></ul></string></li><li>之后，rebuild 这个C/C++ index通过右键项目 –&gt; Index –&gt; Rebuild<br><center><img src="https://ooo.0o0.ooo/2016/12/08/5848aa1e68df6.png" alt="6.png"><center></center></center></li><li>Eclipse提供了一个链接”Source directory”，这样你就能编辑源代码了<br><center><img src="https://ooo.0o0.ooo/2016/12/08/5848aa1e4b13f.png" alt="7.png"></center><h4 id="添加新的源文件"><a href="#添加新的源文件" class="headerlink" title="添加新的源文件"></a>添加新的源文件</h4></li><li>右键src并选择 New –&gt; Source File, 然后新建一个hello.cpp文件<br><center><img src="https://ooo.0o0.ooo/2016/12/08/5848aa1e6a012.png" alt="8.png"></center><h4 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h4><center><img src="https://ooo.0o0.ooo/2016/12/08/5848aa1e89cda.png" alt="9.png"></center><br>默认是Ctrl+Space</li></ul></blockquote><h3 id="C-第一个Node例子"><a href="#C-第一个Node例子" class="headerlink" title="C++第一个Node例子"></a>C++第一个Node例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * hello.cpp</div><div class="line"> *</div><div class="line"> *  Created on: Dec 8, 2016</div><div class="line"> *      Author: volcanoh</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span>** argv)</span></span></div><div class="line">&#123;</div><div class="line">	ros::init(argc, argv, <span class="string">"hello"</span>);</div><div class="line"></div><div class="line">	ros::NodeHandle nh;</div><div class="line">	ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(ros::ok())</div><div class="line">	&#123;</div><div class="line">		ROS_INFO_STREAM(<span class="string">"hello world"</span> &lt;&lt; count);</div><div class="line"></div><div class="line">		ros::spinOnce();</div><div class="line">		loop_rate.sleep(); count++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="ROS-Init"><a href="#ROS-Init" class="headerlink" title="ROS Init"></a>ROS Init</h4><p>ros::init()必须在ROS的其他部分之前调用<br>在main()函数中典型的调用是：</p><pre><code>ros::init(argc, argv, &quot;Node name&quot;);
</code></pre><p>在一个运行的系统中，Node的名字必须是独一无二的。</p><h4 id="ros-NodeHandle"><a href="#ros-NodeHandle" class="headerlink" title="ros::NodeHandle"></a>ros::NodeHandle</h4><p>这是与ROS系统通信的主要访问点。</p><blockquote><ul><li>提供topics、services、parameters等的公共接口<br>在ros::init()之后创建这个节点的handle通过如下申明:<br>ros::NodeHandle node;<ul><li>第一个NodeHandle构造时将会完整的初始化当前节点</li><li>最后一个NodeHandle被析构时将关闭这个节点<h4 id="ROS-Rate"><a href="#ROS-Rate" class="headerlink" title="ROS::Rate"></a>ROS::Rate</h4>这是一个类，它能让你以一个想要的频率调用一个循环。该频率是以Hz为单位。</li></ul></li></ul></blockquote><pre><code>ros::Rate loop_rate(10);
</code></pre><blockquote><ul><li>ros::Rate::sleep()方法<ul><li>在一个循环的剩余时间中睡眠</li><li>这个时间是根据上次sleep、reset或者constructor被调用时开始计算<h4 id="ros-ok"><a href="#ros-ok" class="headerlink" title="ros::ok()"></a>ros::ok()</h4></li></ul></li><li>调用ros::ok()来检查这个节点是否应该继续运行</li><li>ros::ok()将会返回false如果：<ul><li>接受到Ctrl-C信号</li><li>被另外一个有相同名字的节点杀掉</li><li>在这个程序的另外一个位置调用了ros::shutdown()</li><li>所有的ros::NodeHandles都被析构了<h4 id="ROS-Debug-Messages"><a href="#ROS-Debug-Messages" class="headerlink" title="ROS Debug Messages"></a>ROS Debug Messages</h4></li></ul></li><li>ROS_INFO能打印消息<ul><li>ROS_INFO(“My INFO message.”);</li></ul></li><li>所有的消息会伴随着他们的消息等级和时间戳被打印出来<ul><li>[INFO][1231245123.12738912749]:My INFO message.</li></ul></li><li>这个函数的参数如同printf：<ul><li>ROS_INFO(“My INFO message with argument: %f”, val);</li></ul></li><li>有5个典型的等级:<br>*DEBUG, INFO, WARN, ERRORM, FATAL</li><li>ROS<em><level>[</level></em><other>]</other></li><li>支持C++ STL流*_STREAM function<ul><li>ROS_INFO_STREAM(“My INFO stream message with argument:” &lt;&lt; val);</li></ul></li></ul></blockquote><h4 id="编译节点"><a href="#编译节点" class="headerlink" title="编译节点"></a>编译节点</h4><p>在编译节点之前，你需要修改这个包的CMakeLists.txt<br></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</div><div class="line"><span class="keyword">project</span>(first_pkg)</div><div class="line"></div><div class="line"><span class="comment">## Find catkin macros and libraries</span></div><div class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS roscpp rospy std_msgs)</div><div class="line"></div><div class="line"><span class="comment">## Declara catkin package</span></div><div class="line">catkin_package()</div><div class="line"></div><div class="line"><span class="comment">## Declare a cpp executable</span></div><div class="line"><span class="keyword">add_executable</span>(hello src/hello.cpp)</div><div class="line"></div><div class="line"><span class="comment">## Specify libraries to link a library or executable targe against</span></div><div class="line"><span class="keyword">target_link_libraries</span>(hello <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</div></pre></td></tr></table></figure><p></p><p>在eclipse中按Ctrl-B来编译这个project，或者在终端调用catkin_make</p><h4 id="在终端运行节点"><a href="#在终端运行节点" class="headerlink" title="在终端运行节点"></a>在终端运行节点</h4><pre><code>cd ~/catkin_ws
source ./devel/setup.bash
</code></pre><p>或者你能将上面这行加到.bashrc中<br>现在你能用rosrun运行你的节点了：</p><pre><code>rosrun first_pkg hello
</code></pre><center><img src="https://ooo.0o0.ooo/2016/12/08/5848c6164b81c.png" alt="1.png"></center><h4 id="在eclipse中运行节点"><a href="#在eclipse中运行节点" class="headerlink" title="在eclipse中运行节点"></a>在eclipse中运行节点</h4><blockquote><ul><li>创建一个新的launch configuration，点击Run –&gt; Run configurations… –&gt; C/C++ Application（双击）</li><li>在main页里选择正确的二进制文件<code>~/catkin_ws/devel/lib/first_pkg/hello</code></li><li>确保你已经在终端运行了roscore</li><li>点击Run<center><img src="https://ooo.0o0.ooo/2016/12/08/5848c705b2e85.png" alt="2.png"></center><br><center><img src="https://ooo.0o0.ooo/2016/12/08/5848c7370db99.png" alt="3.png"></center></li></ul></blockquote><h4 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h4><p>要让eclipse能够调试，你应该先在catkin_ws/build中执行下列命令：</p><pre><code>cmake ../src -DCMAKE_BUILD_TYPE=Debug
</code></pre><p>重启eclipse<br>然后你就能在eclipse中使用标准的调试工具了</p><center><img src="https://ooo.0o0.ooo/2016/12/08/5848c7f997dcb.png" alt="4.png"></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Agenda&quot;&gt;&lt;a href=&quot;#Agenda&quot; class=&quot;headerlink&quot; title=&quot;Agenda&quot;&gt;&lt;/a&gt;Agenda&lt;/h2&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;ROS的基本命令&lt;/li&gt;&lt;li&gt;ROS开发环境的建立&lt;/li&gt;&lt;li&gt;R
    
    </summary>
    
    
      <category term="ROS Lesson" scheme="http://Kuyman2v.github.io/tags/ROS-Lesson/"/>
    
  </entry>
  
  <entry>
    <title>ROS Lesson1</title>
    <link href="http://Kuyman2v.github.io/2016/12/06/ROS-Lesson1/"/>
    <id>http://Kuyman2v.github.io/2016/12/06/ROS-Lesson1/</id>
    <published>2016-12-06T14:39:18.000Z</published>
    <updated>2017-06-08T03:26:32.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ROS核心概念"><a href="#ROS核心概念" class="headerlink" title="ROS核心概念"></a>ROS核心概念</h2><blockquote><ul><li>Nodes</li><li>Messages and Topics</li><li>Services</li><li>ROS Master</li><li>Parameters</li><li>Stacks and packages</li></ul></blockquote><h2 id="ROS-Nodes"><a href="#ROS-Nodes" class="headerlink" title="ROS Nodes"></a>ROS Nodes</h2><blockquote><ul><li>单个的有目标的执行程序<br>例如，传感器驱动，致动器驱动，mapper,决策，UI等</li><li>独立的编译、执行、管理</li><li>Nodes用ROS的client library写<ul><li>roscpp–C++客户端库</li><li>rospy–python客户端库</li></ul></li><li>Nodes能被发布和订阅到一个Topic</li><li>Nodes能提供或者使用一个Service</li></ul></blockquote><h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><blockquote><ul><li>一个Topic是为已定义类型的信息流取的一个名字<br>例如，来自laser的数据被发送在一个叫<code>scan</code>的topic上，它的数据类型是<code>LaserScan</code></li><li>Nodes之间的相互通信是通过把messages发布到topic上</li><li>发布/订阅 模型是1-to-N广播式的</li></ul></blockquote><center><img src="https://ooo.0o0.ooo/2016/12/07/5847faf1cfe60.png" alt="ros-topic.png"></center><h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><center><img src="https://ooo.0o0.ooo/2016/12/07/5847fba382a04.png" alt="ros-graph.png"></center><h2 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h2><blockquote><ul><li>为内部Nodes交流而严格定义的数据结构</li><li>例如，geometry_msgs/Twist 被用来表达速度指令<ul><li>Vector3 linear<ul><li>float64 X</li><li>float64 Y</li><li>float64 Z</li></ul></li><li>Vector3 angular</li></ul></li></ul></blockquote><h2 id="Servece"><a href="#Servece" class="headerlink" title="Servece"></a>Servece</h2><blockquote><ul><li>同步的内部节点交互</li><li>客户端/服务器 模型：1-to-1应答式</li><li>Service的角色<ul><li>执行远程计算</li><li>触发功能/行为</li></ul></li><li>例如，map_server/static_map :取回被机器人导航使用的网格地图</li></ul></blockquote><h2 id="ROS-Master"><a href="#ROS-Master" class="headerlink" title="ROS Master"></a>ROS Master</h2><blockquote><ul><li>为Nodes提供连接信息使得它们能够相互之间传递信息<ul><li>每个Node在启动的时候都会与master相连，并会注册它们要发布和订阅的信息流的细节</li></ul></li><li>假如我们有两个节点:一个Camera节点和一个Image_viewer节点</li><li>典型的，camera节点将会在”images”topic上发布图像<center><img src="https://ooo.0o0.ooo/2016/12/07/5848004d1eb55.png" alt="master1.png"></center></li><li>现在，Image_viewer想要订阅”image”topic来看这里是否有图像：<center><img src="https://ooo.0o0.ooo/2016/12/07/584800c478d4a.png" alt="master2.png"></center></li><li>现在，”image”topic有了发布者和订阅者，master节点会告知camera和Image_viewer它们相互的存在，使得它们能够开始传输图像<center><img src="https://ooo.0o0.ooo/2016/12/07/584801bdab2c1.png" alt="master3.png"></center></li></ul></blockquote><h2 id="Parameter-Server"><a href="#Parameter-Server" class="headerlink" title="Parameter Server"></a>Parameter Server</h2><blockquote><ul><li>一个共享的多变量词典，能够被networks APIs访问</li><li>最好是被静态的、非二进制数据使用，例如配置参数</li><li>在ROS master内部运行<br><center><img src="https://ooo.0o0.ooo/2016/12/07/584802ae858e4.png" alt="master4.png"></center></li></ul></blockquote><h2 id="ROS-Packages"><a href="#ROS-Packages" class="headerlink" title="ROS Packages"></a>ROS Packages</h2><blockquote><ul><li>ROS中的软件用packages组织</li><li>一个package包含一个或者更多的节点并且提供一个ROS接口</li><li>大部分的ROS packages 都在github中托管着<center><img src="https://ooo.0o0.ooo/2016/12/07/5848037b2ac10.png" alt="package.png"></center><br>## ROS Packages System<br><center><img src="https://ooo.0o0.ooo/2016/12/07/584803eb30fee.png" alt="package-system.png"></center></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ROS核心概念&quot;&gt;&lt;a href=&quot;#ROS核心概念&quot; class=&quot;headerlink&quot; title=&quot;ROS核心概念&quot;&gt;&lt;/a&gt;ROS核心概念&lt;/h2&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;Nodes&lt;/li&gt;&lt;li&gt;Messages and Topics
    
    </summary>
    
    
      <category term="ROS Lesson" scheme="http://Kuyman2v.github.io/tags/ROS-Lesson/"/>
    
  </entry>
  
</feed>
